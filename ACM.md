#### 回溯

---

1. 解题思想：
   + 解向量，解搜索树 长啥样
   + 用模板遍历搜索树



2. 用全局变量记录解向量

   **n皇后中紫书的两个写法就代表了两类全局变量的处理方法**

   **核心是要保证cur轮赋值的全局变量对回溯到它的兄弟的时候没有影响**

   

3. 模板

   ```c++
   void dfs(cur)//本轮给cur号解向量赋值，此时cur-1及之前的部分解向量是可行的
   {
   	if(cur>n){
   		//更新最优解
   		return;
   	}
   	for(枚举兄弟节点){
   		if(当前节点可行){
               解向量[cur] = 当前节点取值;//或者其它全局变量
               //全局变量记录的不是解向量的时候很可能dfs的下一行就得恢复回来
               dfs(cur+1);
               //若当前节点对全局变量的改变，下一轮没法被下一轮的赋值覆盖时，就要在这里恢复回来
           }
   	}
   }
   ```

   

4. 全局变量不用在dfs下面特意改回来的例子

   从1-n中选m个数从小到大输出

   ```c++
   void chooserow(int cur){//cur记录该选择到第几行了，1，2。。。m行 ，本轮应该选择cur行 
   	if(cur>m){//开始找路径 
   		dfs(1);
   		return ;
   	}
   	for(int i = row[cur-1]+1;i<=n-m+cur;i++){
   		row[cur] = i;
   		chooserow(cur+1);
   	}
   } 
   ```

5. 只需要遍历部分搜索树的时候

   我的方法是加一个flag判断

   + if（）终止递归的条件加上&&flag

   + for循环的时候，为了避免进入当前应当结束的节点的兄弟节点的时候，应该加上flag判断



for循环体中，赋值的时候错用不是j的循环变量



**若想终止整个的回溯过程**

至少需要写三处

+ if(cur>n||flag)
+ for枚举所有的子节点的时候，注意是否需要再i<n后面加上&&flag==false，否则会继续回溯到兄弟节点上的

